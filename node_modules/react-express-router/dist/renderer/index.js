"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const elements_1 = require("../elements");
const types_1 = require("../types");
const react_reconciler_1 = __importDefault(require("react-reconciler"));
const compileExpressRoutes_1 = require("./compileExpressRoutes");
const HostConfig = {
    now: Date.now,
    getRootHostContext() {
        const rootContext = {};
        return rootContext;
    },
    getChildHostContext(parentContext, fiberType, rootInstance) {
        const context = { type: fiberType };
        return context;
    },
    shouldSetTextContent() {
        return false;
    },
    createTextInstance() {
        throw new Error('createTextInstance not supported');
    },
    createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress) {
        return elements_1.createInstance(type, newProps);
    },
    appendInitialChild: (parent, child) => {
        parent.appendChild(child);
    },
    finalizeInitialChildren: () => {
        return false;
    },
    prepareForCommit() {
    },
    resetAfterCommit() {
    },
    appendChildToContainer: (parent, child) => {
        parent.appendChild(child);
    },
    supportsMutation: true,
    prepareUpdate() {
        return false;
    },
    commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork) {
        instance.update(oldProps, newProps);
    },
    commitTextUpdate(textInstance, oldText, newText) {
        throw new Error('commitTextUpdate not supported');
    },
    appendChild(parentInstance, child) {
        parentInstance.appendChild(child);
    },
    insertBefore: (parentInstance, child, beforeChild) => {
        parentInstance.insertBefore(child, beforeChild);
    },
    removeChild(parentInstance, child) {
        parentInstance.removeChild(child);
    },
    insertInContainerBefore(container, child, beforeChild) {
        container.insertBefore(child, beforeChild);
    },
    removeChildFromContainer(container, child) {
        container.removeChild(child);
    },
    resetTextContent() {
    },
};
const reconcilerInstance = react_reconciler_1.default(HostConfig);
const CustomRenderer = {
    generate(element) {
        const rootContainer = elements_1.createInstance(types_1.Elements.Root);
        const mountNode = reconcilerInstance.createContainer(rootContainer);
        reconcilerInstance.updateContainer(element, mountNode, null);
        return rootContainer.render();
    },
    compile(generated) {
        return compileExpressRoutes_1.compileRoute(generated);
    },
};
exports.default = CustomRenderer;
